<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5" />
    <title>bercriber's blog</title>
    <link rel="stylesheet" href="/css/base.css">
    <link rel="icon" href="/public/favicon.ico" />
    
  </head>
  <body>
    
      <header class="header">
        <h2 class="header-title">Bercriber's Blog</h2>
        <img class="header-icon" src="/public/bercriber.jpg" />
      </header>
    

    
    
  </body>
</html>


<div class="tags-list">


  
    <a class="tags-list-elem" href="/blog/tag/プログラミング">プログラミング</a>
  

</div>




<div class="post-header">
  <p class="post-date">2022/08/11 20:33</p>
  <hr>
  <h2 class="post-title">zigでinterface的なやつ</h2>
</div>

<div class="post-main">

  <p>fieldParentPtrイディオムは極めてシンプルな実装になっている。しかしfieldParentPtrイディオムはLLVMの最適化と相性が悪いらしい。zig ver0.9からはAllocgateと呼ばれる手法でstd.mem.Allocatorやstd.rand.Randomが多相化されている。<code>*anyopaque</code>を使って型を無視することで動的に実装を選択できるようになっている。ええんかそれで。標準ライブラリでそれやってるくらいならそのうちに言語機能にtraitなりinterfaceなり実装されそうな気がするが、これの構文糖みたいなもんになるのだろうか。</p>
<pre><code class="language-zig">const std = @import(&quot;std&quot;);

/// Use @fieldParentPtr
/// https://zig.news/david_vanderson/interfaces-in-zig-o1c
const FooI = struct {
    fooFn: fn(*FooI) void,
    fn foo(self: *FooI) void {
        self.fooFn(self);
    }
};

const Bar = struct {
    sym: u8,
    fooI: FooI,
    fn init() Bar {
        return .{ .sym = 0xff, .fooI = FooI { .fooFn = fooFn } };
    }
    fn fooFn(fooI: *FooI) void {
        const self = @fieldParentPtr(Bar, &quot;fooI&quot;, fooI);
        std.debug.print(&quot;foo({}) from Bar\n&quot;, .{self.sym});
    }
};

/// Allocgate
/// https://pithlessly.github.io/allocgate.html
/// https://github.com/ziglang/zig/blob/master/lib/std/mem/Allocator.zig
/// https://github.com/ziglang/zig/blob/master/lib/std/rand.zig
const HogeI = struct {
    ptr: *anyopaque,
    hogeFn: fn (ptr: *anyopaque) void,
    fn init(pointer: anytype, comptime hogeFn: fn (ptr: @TypeOf(pointer)) void) HogeI {
        const Ptr = @TypeOf(pointer);
        std.debug.assert(@typeInfo(Ptr) == .Pointer); // Must be a pointer
        std.debug.assert(@typeInfo(Ptr).Pointer.size == .One); // Must be a single-item pointer
        std.debug.assert(@typeInfo(@typeInfo(Ptr).Pointer.child) == .Struct); // Must point to a struct
        const gen = struct {
            fn hoge(ptr: *anyopaque) void {
                const alignment = @typeInfo(Ptr).Pointer.alignment;
                const self = @ptrCast(Ptr, @alignCast(alignment, ptr));
                @call(.{.modifier = .always_inline}, hogeFn, .{self});
            }
        };
        return .{
            .ptr = pointer,
            .hogeFn = gen.hoge
        };
    }

    fn hoge(self: HogeI) void {
        self.hogeFn(self.ptr);
    }
};

const Fuga = struct {
    sym: u8,
    fn init() Fuga {
        return .{
            .sym = 0xff / 2
        };
    }

    fn hogeI(self: *Fuga) HogeI {
        return HogeI.init(self, hogeFn);
    }

    fn hogeFn(self: *Fuga) void {
        std.debug.print(&quot;hoo({}) from Fuga\n&quot;, .{self.sym});
    }
};



pub fn main() !void {
    var bar = Bar.init();
    bar.fooI.foo();

    var fuga = Fuga.init();
    var hogeI = fuga.hogeI();
    hogeI.hoge();
}
</code></pre>


</div>
