<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5" />
    <title>bercriber's blog</title>
    <link rel="stylesheet" href="/css/base.css">
    <link rel="icon" href="/public/favicon.ico" />
    
  </head>
  <body>
    
      <header class="header">
        <h2 class="header-title">Bercriber's Blog</h2>
        <img class="header-icon" src="/public/bercriber.jpg" />
      </header>
    

    
    
  </body>
</html>


<div class="tags-list">


  
    <a class="tags-list-elem" href="/blog/tag/プログラミング">プログラミング</a>
  

</div>




<div class="post-header">
  <p class="post-date">2024/12/03 14:02</p>
  <hr>
  <h2 class="post-title">Haskellでゲームボーイエミュレータ</h2>
</div>

<div class="post-main">

  <p><a href="https://qiita.com/advent-calendar/2024/haskell">Haskell Advent Calendar 2024 3日目</a>の記事です。</p>
<p>TypescriptやZigでゲームボーイエミュレータを書いたことがあったので<a href="https://github.com/kmtoki/gbe-hs/">Haskellでも試して見ました。</a>CPUまで書いて力尽きたのでゲームは遊べません。自分でゲームボーイエミュレータ書いてみたいという方は<a href="https://gbdev.io/pandocs/">gbdev.io</a>を見ればだいたいなんとなくおおよそたぶんわかるかと思います。</p>
<p>エミュレータはCPUの命令を実行するたびにレジスタやメモリなどを逐次更新していくことになるのでミュータブルの方が効率が良いと思います。素直にIORefやVector.Mutableなどを使うのがよいと思うわけですが、StateMとLensを使えばミュータブルっぽいインターフェイスですっきり書けそうな気がしました。気がしたんです。</p>
<pre><code class="language-haskell">type CPU a = StateT CPUState (StateT MBCState (StateT LoggerState IO)) a

data CPUState = CPUState {
    -- レジスタなど
    _a, __f, ..., :: Word8,
    _pc, _sp, :: Word16,
    ...
    }

makeLenses ''CPU

-- 8ビットレジスタを２つ並べて擬似的に16ビットレジスターとしている
af :: Lens' CPUState Word16
af = lens get set
  where
    get cpu = toWord16 (_a cpu) (__f cpu)
    set cpu ww = cpu { _a = _a', __f = __f'' }
      where
        (_a',__f') = sepWord16 ww
        __f'' = __f' .&amp;. 0b11110000

-- fレジスタの上位4ビットに各種フラグが格納されている
carry :: Lens' CPUState Bool
carry = lens get set
  where
    get cpu = testBit (__f cpu) 4
    set cpu b =
      if b then
        cpu { __f = setBit (__f cpu) 4 }
      else
        cpu { __f = clearBit (__f cpu) 4 }


-- CPUの命令
add :: OP -&gt; CPU ()
add op = do
  a' &lt;- use a -- aレジスタの読み取り
  w &lt;- readOP8 op
  let (a'', c', h') = add8WithCarryHalf a' w
  a .= a'' -- aレジスタの更新

  -- フラグの更新
  zero .= isZero a''
  negative .= False
  half .= h'
  carry .= c'

call :: OP -&gt; CPU ()
call op = do
  ww &lt;- readOP16 WW -- ROM/プログラムから2byte/Word16分の即値を読んでる
  pc' &lt;- use pc
  bool &lt;- cond op -- carryフラグやzeroフラグのオンオフによってジャンプするかしないか
  when bool $ do
    push16 pc'
    pc .= ww
</code></pre>
<p><a href="https://github.com/kmtoki/gbe-hs/blob/MonadStackState/src/Gameboy/CPU.hs">gbe-hs/MonadStackState</a></p>
<p>ログ用のStateとメモリやROMアクセスを仲介するMBC（メモリバンクコントローラー）用のStateも管理する必要があるためMonadスタックに積み上がってます。主にレコードのフィールドに置いたレジスタの更新にStateMとLensを使っています。</p>
<p>面白い点としては、self的なのがStateMによって隠蔽されてるので明示せずともよい所。各種フラグやレジスタのカスタムアクセサーがlens関数で定義できるのも良い点です。悪い点としては楽したいがためにレジスタの名前をaとかにしてるので一時変数の名前に困り、<code>a'</code>、<code>a''</code>とかになって大変わかりずらい点（自分の名前付けが悪いが書いてるときは楽だった気もする）。</p>
<p>たとえばRustで似たような実装にすればselfの明示が必要になるかと思います。部分的に見ればHaskellのほうがスッキリしているようにも見えます。</p>
<pre><code class="language-rust">fn add(&amp;mut self, op: OP)  {
    let (a, carry, half) = self.a.add_carry_half(self.load8(op));
    self.a = a;
    self.set_carry(carry);
    self.set_half(half);
    self.set_negative(false);
    self.set_zero(self.a == 0);
}

fn call(&amp;mut self, op: OP)  {
    let pc = self.fetch16();
    if self.cond_flag(op) {
        self.push16(self.pc);
        self.pc = pc;
    }
}
</code></pre>
<p>さて、上記の実装のような方針で一通り書いて動かしてみたらとても遅い。うちの7950xでもコンパイルに10秒くらいかかるのはいいとしても、実行で<a href="https://github.com/retrio/gb-test-roms/tree/master/cpu_instrs">エミュレータ開発用のテストROM</a>が落ちるまでに二分ほどかかるのはとてもかなしい（後述の実装では約6秒）。ここまで動くようにするのにStateMとLensと格闘した結果がこれだったのと、昔書いたdeno/typescript版が一秒で起動して約２０秒で実行が終わっていたのもあり、しなしなになり力尽きました。正直テスト通ってないのでどこかでバグり散らかしているせいかもしれませんが。</p>
<p>少しの療養をとったあと、もう少しどうにかならんかと手を入れました。まずモナドスタックが重いのではないかと思いモナドスタックをフラットにしました。</p>
<pre><code class="language-haskell">
-- 最初の実装
type CPU a = StateT CPUState (StateT MBCState (StateT LoggerState IO)) a

-- メモリアクセスのたびliftが発生する
read :: Address i =&gt; i -&gt; CPU Word8
read i = do
  cycle += 1
  lift $ do
    reader' &lt;- use reader
    reader' $ toInt i



-- モナドスタック潰した結果
type GB a = StateT GBState IO a

data GBState = GBState {
  _cpu :: CPUState,
  _mbc :: MBCState,
  _logger :: LoggerState
  }

read :: Address i =&gt; i -&gt; GB Word8
read i = do
  cpu.cycleM += 1
  r &lt;- use $ mbc.reader
  r $ toInt i

add :: OP -&gt; GB ()
add op = do
  a' &lt;- use $ cpu.a
  w &lt;- readOP8 op
  let (a'', c', h') = add8CarryHalf a' w

  -- StateMの命令(.=)を複数並べていたのを(%=)一つにまとめている
  cpu %= 
      (a .~ a'')
    . (zero .~ isZero a'')
    . (negative .~ False)
    . (half .~ h')
    . (carry .~ c')
</code></pre>
<p><a href="https://github.com/kmtoki/gbe-hs/blob/global-state/src/Gameboy/CPU.hs">gbe-hs/global-state</a></p>
<p>モナドスタックを潰した結果として、先ほどのself的なのを書かなくてもいいという利点が消えました。CPUの命令がGB（GameBoy）モナドになっているためです。CPUのためだけの関数なのでスコープを限定したいのですが、実質グローバルステートで各Stateにアクセスできるようにするためこうなってます。(.=)を(%=)にしてStateモナドの命令をまとめているのでコストが下がってる気がしますたぶん。先ほどと同じテストROMを落ちるまで回して2倍くらい早い実行速度になりました。よかったねと言いたい所ですがとてもゲームがプレイアブルな速度にはなってはいなく、やはり悲しみとともに力尽きました。</p>
<p>しばらくの療養を終えたあと、さすがにhaskellがこんなに遅いわけない。ごりごり最適化すればC++並の速度がでるとかでないとかって昔見たような気がするぞわすれたけど。と思い直し、とりあえずすべてのレジスタをVector.Unboxed.Mutableにぶちこめばましになるやろの方針で書き直しました。</p>
<pre><code class="language-haskell">import Data.Vector.Unboxed.Mutable qualified as VM

newtype Store a = Store (VM.MVector (VM.PrimState IO) a)

data CPU = CPU { 
  mbc :: MBC,
  cpuLogger :: Logger CPULog,

  regs8 :: Store Word8,
  regs16 :: Store Word16,
  }


data CPUFlags = Carry | Half | Negative | Zero
  deriving (Enum, Show)

data CPURegisters8 = A | F | B | C | D | E | H | L | IME | Halt | Cycle | IsLogging
  deriving (Enum, Show, Eq)

data CPURegisters16 = SP | PC
  deriving (Enum, Show)

readReg8 :: CPU -&gt; CPURegisters8 -&gt; IO Word8
readReg8 (CPU {..}) r = readStore regs8 $ fromEnum r

readReg16 :: CPU -&gt; CPURegisters16 -&gt; IO Word16
readReg16 (CPU {..}) r = readStore regs16 $ fromEnum r

writeReg8 :: CPU -&gt; CPURegisters8 -&gt; Word8 -&gt; IO ()
writeReg8 (CPU {..}) r n = writeStore regs8 (fromEnum r) n

writeReg16 :: CPU -&gt; CPURegisters16 -&gt; Word16 -&gt; IO ()
writeReg16 (CPU {..}) r n = writeStore regs16 (fromEnum r) n

readFlag :: CPU -&gt; CPUFlags -&gt; IO Bool
readFlag cpu flag = do
  f &lt;- readReg8 cpu F
  pure $ testBit f $ 4 + fromEnum flag

writeFlag :: CPU -&gt; CPUFlags -&gt; Bool -&gt; IO ()
writeFlag cpu flag bool = do
  f &lt;- readReg8 cpu F
  let f' = (if bool then setBit else clearBit) f (4 + fromEnum flag)
  writeReg8 cpu F $ f' .&amp;. 0b11110000


add :: CPU -&gt; Op8 -&gt; IO ()
add cpu op = do
  a &lt;- readReg8 cpu A
  n &lt;- readOp8 cpu op
  let (a', carry, half) = addCarryHalf a n
  writeReg8 cpu A a'
  writeFlag cpu Carry carry
  writeFlag cpu Half half
  writeFlag cpu Negative False
  writeFlag cpu Zero $ a' == 0

call :: CPU -&gt; OpCond -&gt; IO ()
call cpu op = do
  nn &lt;- fetch16 cpu

  bool &lt;- condFlag cpu op
  when bool $ do
    pc &lt;- readReg16 cpu PC
    push16 cpu pc
    writeReg16 cpu PC nn
</code></pre>
<p><a href="https://github.com/kmtoki/gbe-hs/blob/main/src/GB/CPU.hs">gbe-hs/main</a></p>
<p>レジスタの値はWord8/16でだいたいいけるのでUnboxedが十分使えました。Stateモナドを撤廃したことでCPUレコードを引数として明示する必要が出てきました。レコードの中身がすべてIOVectorなので状態の引き回しについて考える必要がなかったのが楽でした。レジスターアクセスも直和型として定義したデータ型がそのまま<code>deriving(Enum)</code>で配列の添字に使えるのでスッキリしました。</p>
<p>StateM/Lensを使えばスッキリ書けるんじゃないかという目論見は部分的によかったかと思いますが、実用的な速度はでなかったので結局素朴な実装になりました。先程と同じテストROMが約6秒で通るようになり最初の実装から約20倍早くなりゲームプレイもできるレベルであろうと安心して力尽きました。後から書いた<a href="https://github.com/kmtoki/gbe-rs">Rustの実装</a>だと3秒だったので悪くないんじゃないんでしょうかねというかRustもなんか遅い気がしないでもない。</p>
<p>ほどよい歯ごたえだと思うのでみなさんもHaskellでゲームボーイエミュレータ書いてみませんか。λ...</p>
<p><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/b/bercriber/20241203/20241203141052.png" alt=""></p>


</div>
